{"pageProps":{"frontmatter":{"slug":"/blog/migrating-google-login-from-openid-20-to-google-2","date":"Sun, 26 Jan 2014 17:15:00 GMT","title":"Migrating Google login from OpenID 2.0 to Google+ (Part 2 of 3)","epoch":"1390756500"},"markdownBody":"\n\n([Part 1 of this story](/blog/migrating-google-login-from-openid-20-to-google-1))\n\n\nGoogle published an article in December 2013 that says \"[Upgrading to Google+ Sign In](https://developers.google.com/+/api/auth-migration)\". There it says that if you add \"data-openidrealm\" to your G+ button, you could get the user\"s OpenID ident. Woah! That will solve my problem!\n\n\nReading through the document, though, turned out that it might not be that easy - because the document tells how to do that only by using either Client-side flow of Hybrid server-side flow - some things they recommend. Our sign-in however is completely done in Pure server-side flow (because it was OpenID before). Migrating the \"Login\" button itself to adapt to Hybrid flow is not impossible but it will be painful.\n\n\nSo, I started to hack over the document. The document basically says you just add your OpenID realm (or [trust_root](https://metacpan.org/pod/Net::OpenID::ClaimedIdentity#trust_root)) to data-openidrealm attribute to your button\"s element, and it does all the heavy lifting. It then links to the [page that describes OpenID Connect.](https://developers.google.com/accounts/docs/OpenID#openid-connect) It says that\n\n\n```\nFor applications that use OpenID 2.0, the authentication request URI may include an openid.realm parameter.\n```\n\n\nOK that\"s what I want to hear. So this code should do\n\n\n```\nmy $uri = URI->new( 'https://accounts.google.com/o/oauth2/auth' );\n $uri->query_form(\n client_id => _config()->{ client_id }\n , response_type => 'code'\n , scope => 'https://www.googleapis.com/auth/plus.login'\n , access_type => 'online'\n , redirect_uri => _redirect_uri()\n , state => time()\n , 'openid.realm' => 'http://peatix.com'\n );\n return $c->res->redirect( $uri );\n```\n\n\nThe only part that is really different from what we use for Facebook login (which is also based on OAuth2 but different draft version) is the last argument that sets &lsquo;openid.realm\".\n\n\nThe response to the /token endpoint was something like this\n\n\n```\n{\n \"access_token\" : \"...\",\n \"token_type\" : \"Bearer\",\n \"expires_in\" : 3600,\n \"id_token\" : \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVmMWY0ZTc3MWU5OTdkMjFhMDhhZGQ4M2FjYmYxOGM2Y2I0ZTU0NzMifQ.eyJ...\"\n}\n```\n\n\n&hellip; well, where is my OpenID ident?\n\n\nI went back to the [OpenID Connect page](https://developers.google.com/accounts/docs/OpenID#map-identifiers) again and found that id_token is what should bear it inside. OK. what is this id_token thing?\n\n\nId_token is encoded in the format called JSON WebToken. It\"s basically cryptographically signed JSON. I must decode this in order to get the OpenID ident. Searching metacpan.org easily found this gem, er, cpan module, [JSON::WebToken](https://metacpan.org/pod/JSON::WebToken). Oh Perl mongers, how I love thou! Now I just need to `cpanm JSON::WebToken` and call JSON::WebToken->decode( $res->{ id_token }, $key ). Wait, what should I use as $key?\n\n\nNext up: [finding the key to decode JWT](/blog/migrating-google-login-from-openid-20-to-google-3).\n\n","navs":{"nextPage":{"epoch":"1390759380","title":"Migrating Google login from OpenID 2.0 to Google+ (Part 3 of 3)","slug":"/blog/migrating-google-login-from-openid-20-to-google-3"},"prevPage":{"epoch":"1390753800","title":"Migrating Google login from OpenID 2.0 to Google+ (Part 1 of 3)","slug":"/blog/migrating-google-login-from-openid-20-to-google-1"}}},"__N_SSG":true}