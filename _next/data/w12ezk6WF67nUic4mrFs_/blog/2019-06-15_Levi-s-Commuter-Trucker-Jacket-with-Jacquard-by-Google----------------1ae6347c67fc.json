{"pageProps":{"frontmatter":{"slug":"/blog/2019-06-15_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google----------------1ae6347c67fc","date":"Sat, 15 Jun 2019 15:44:21 GMT","title":"Levi’s Commuter Trucker Jacket with Jacquard by Googleの袖を手書き認識デバイスにする","epoch":"1560613461","excerpt":"ジャケット（についてるsnap tag）からJacquardの糸に触れたときの連続的なデータを使って遊んでみる。"},"markdownBody":"\n### Levi’s Commuter Trucker Jacket with Jacquard by Googleの袖を手書き認識デバイスにする\n\n[前回まで](/blog/2019-06-01_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google------------8b56fb4732d7)のコードで、ジャケット（についてるsnap tag）から飛んでくる情報、特にJacquardの糸に触れたときのなんというか連続的なデータをアプリで取得できるようになった。今のところこの情報は公式アプリでもデモ目的以外には使われていなくて、Double TapやBrush In/Outなどのイベントはsnap tag側で先に判別された上で、そのIDがある種デジタルな、離散的な値として飛んできて、公式アプリはそれに対して反応することができるだけになっている。\n\n連続的なデータを使って何かできないかということで思いついたのが、袖をなぞって発生する一連のデータを文字として認識させて、キーボードのように使えるようにすること。それを実現するために、何度もある文字をなぞったデータを機械学習にかけて、15本の糸のなぞられ方から文字を判別するモデルを作成して、あわよくばそれをアプリ上で実行してキーボードのように使う。\n\n機械学習とかやったことないしPythonもほとんど書いたことないのだが、まあStackoverflowでなんとかなるだろうと思って始めてみた。\n\n### 学習用データの収集\n\n学習させたいデータがないと学習させられないので、まずはデータを作る。最初は糸1本ごとの触られっぷりを示すらしき1バイトのデータをそれぞれカラムとして保存して、さらに1つの文字を書くのにある程度の数のデータが連続して送られてくるので、1文字の書き始めと書き終わりまでの系列データを並べた2次元の配列を考えた。一方の軸の大きさは15で固定で、もう一方の軸の大きさは文字の書き終わりまでに送られていたイベント数ということになる。\n\nこのアプリ上で、教師あり学習用のデータを作るためにa, b, cの文字ををそれぞれ10回程度ずつなぞって、書き終わるたびに1つの文字のデータとして記録して、ログを吐き出した。したがって吐き出されたデータはこんなのが並んでるファイルとして保存される。\n\n```\n0,0,c,d,0,1,2,3,4,5,0,0,0,0\n0,0,0,0,4,3,2,1,a,a,a,a,0,0\n0,0,0,0,c,d,0,1,2,3,4,5,0,0\n0,0,0,0,0,0,4,3,2,1,a,a,a,0\n…\n```\n\nさて少量ながらデータが集まったので、解析してみる。ググってStackoverflowして行くと、やろうとしていることはいわゆるカテゴリー（クラス）分けで、「教師あり学習で分類を行う」ということになるらしい（反対語? は「教師なし学習」「回帰」らしい）。”supervised classification algorithm” とか、さらに”small dataset”で検索してみると、support vector machine (SVM) またはNaive Bayesというアルゴリズムがあること、これらのアルゴリズムをお手軽に使えるツールとしてscikit-learnというのが使えることがわかった。scikit-learnがPythonで使えるモノであるということは知ってるし、Naive BayesアルゴリズムはCPANモジュールもあって前職でお遊びながら使ったことがあった、という程度の知識でスタート。\n\n### scikit-learnで使える学習データを作る\n\nscikit-learnとNaive Bayesで検索してみるといくつか入門記事が見つかるのだが、そのほとんどが[irisつまりアヤメのデータからそのアヤメの分類を当てるという例](https://www.ritchieng.com/machine-learning-iris-dataset/)が出てくるので、とりあえずそれをやってみる。写経して動かして、ははあなるほど、と。\n\n次にirisのデータを自分のデータに置き換える方法を探ってみる。irisのデータは1つの種ごとに4つのカラム（petalのwidthとlength, sepalのwidthとlength）があって、それらが3種類のアヤメに分けられるらしい。それをこんな風にデータ化している。\n\n```\n[\n [ 5.1 3.5 1.4 0.2]\n [ 4.9 3. 1.4 0.2]\n [ 4.7 3.2 1.3 0.2]\n [ 4.6 3.1 1.5 0.2]\n [ 5. 3.6 1.4 0.2]\n …\n]\n```\n\nこちらが使いたいデータはさっき書いたように1つの文字に対して2次元の配列になっている。こういう風に単純に置き換えて渡してみてもエラーになる。\n\n```\n[\n [\n [0,0,12,13,0,1,2,3,4,5,0,0,0,0],\n [0,0,0,0,4,3,2,1,10,10,10,10,0,0],\n [0,0,0,0,12,13,0,1,2,3,4,5,0,0],\n [0,0,0,0,0,0,4,3,2,1,10,10,10,0],\n …\n ],\n …\n]\n```\n\n```\nValueError: Found array with dim 3. Expected &lt;= 2\n```\n\n次元が多すぎるってことで、次元を減らすために適当にググって見つけたこんなコードで適当に次元を減らす。\n\n```\nX = X.reshape(X.shape[0], -1)\n```\n\n一応走りはするものの、こんな次元の減らし方では特徴を正しく捉えたデータになっているとは思えない。\n\nつまり、糸1本1本を別のカラム（次元）として扱うとこれら連続データをただしく渡せないことがわかったので、データの取り方を変えて、1イベントにつき1列で15本の糸のデータを表す値を作ることにした。具体的にはこんな感じで0本目の糸のデータには2**0を、1本目の糸のデータには2**1をそれぞれかけて…とやって1つの大きな数値を作ることにした。これで意味が失われていないのかすごく疑問だが、まあドンマイ。\n\n```\nvar data = 0\nbytes.forEach { byte -&gt;\n val digit = Math.pow(2.toDouble(), (bytes.size — 1).toDouble())\n data += Math.ceil(digit * byte).toInt()\n}\n```\n\nこうして、1つの文字に対してこんな数値が並んだデータを再度a, b, cごとに10ずつくらい作り直して、Python再開。\n\n```\n5931008,\n5308416,\n5013504,\n3473408,\n…\n```\n\n### scikit-learnでモデルを作る\n\nさっきと同じように、irisのデータを作っている箇所を自分のデータ用に変形してみる。当然ながら、それぞれの文字のそれぞれの学習データの大きさは同じでないといけないので、適当にファイルをいくつか眺めて、1つの文字のデータ行数を51にして、連続する同じデータはすべて削ってしまうことにした。これもデータの意味を消してしまっている気がするがドンマイ。\n\nPerlスクリプトをちょいちょい書いてデータを揃えたら、そのファイルをPythonで読み取って、データを食わせてテストしてみる。データ数が少なすぎるし信頼性は低いけど、とりあえずできた。\n\n```\nimport os\nimport re\n```\n\n```\nimport numpy as np\n# from sklearn.svm import SVC\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\n```\n\n```\nLABELS = [‘a’, ‘b’, ‘c’]\n```\n\n```\n# read all data and make an array of array of data\npath = ‘./normalized/’\ndata = {‘a’: [], ‘b’: [], ‘c’: []}\nfor f in os.listdir(path):\n datum = []\n m = re.match(r’(\\w)_(\\d)\\.txt’, f)\n if (m is None):\n continue\n char = m.group(1)\n with open(os.path.join(path + f), ‘r’) as lines:\n for line in lines:\n datum.append(int(line.rstrip()))\n data[char].append(datum)\n```\n\n```\n# construct the ml stuff\n```\n\n```\ntarget = []\nsamples = []\nfor char, ar in data.items():\n for datum in ar:\n target.append(LABELS.index(char))\n samples.append(datum)\n```\n\n```\n# clf = SVC()\nclf = GaussianNB()\nX = np.array(samples)\ny = np.array(target)\nX_train, X_test, y_train, y_test = train_test_split(samples, target, test_size=0.1, random_state=0)\n```\n\n```\nclf.fit(X_train, y_train)\nprint clf.score(X_train, y_train)\n```\n\n```\nprint clf.predict(X_test)\nprint y_test\n```\n\n```\n$ python t1.py\n0.7941176470588235\n[2 0 2 0]\n[2, 1, 2, 2]\n```\n\n### Tensorflowで同じことをやってみる\n\n目的は作ったモデルをAndroidアプリにデプロイして、入力されたデータから文字を推測することなので、scikit-learnで作ったモデルだとやりづらそう。\n\nTensorflowでモデルを作ればTensorflow LiteでAndroidアプリ上で利用できることは知っていたので、scikit-learnで作ったモデルをTensorflowのモデルに変換できるのかを調べたが、まあよくわからないけど簡単にはできませんよね。Tensorflowはニューラルネットワークのためのもので、SVCとかGaussianNBとかはそうじゃないとかなんとかよくわからん。\n\nそれじゃあTensorflowで似たような感じで分類を行うことはできるのかと思って、”Tensorflow iris”とかでググったら[TensorflowにもDNNClassifierというものがあってアヤメの分類ができる](https://www.tensorflow.org/guide/premade_estimators)らしい。早速それを行なっているコードをサンプルから探して、実行してみて、自分のデータで置き換えてみるというさっきと同じ作業を今度はTensorflowのコードでやってみる。まあ[できたのはできた](https://gist.github.com/fumiakiy/cc9107e2f4b66dbc0a20ee1eabc04dc1)。全然当たってないけど。\n\n```\n$ python tf.py\n```\n\n```\nTest set accuracy: 0.788\n```\n\n```\nPrediction is “2” (100.0%), expected “2”\n```\n\n```\nPrediction is “2” (66.6%), expected “0”\n```\n\n```\nPrediction is “2” (66.6%), expected “1”\n```\n\n### 文字を増やす\n\nここまでやっている間ずっと心配に思っていたのは、aと**d**やbと**h**やcと**e**を本当にこんなデータで区別できるのかということ。そこで、d, e, h, o, yの5つの文字をさらに10ずつくらいログにとって、同じPerlスクリプトで整形して、[scikit-learnのコード](https://gist.github.com/fumiakiy/b8018b441d51639d3690ad003bebce0a)にかけてみた。\n\n```\n$ python sk2.py\n0.49504950495049505\n[6 1 0 1 6 0 6 5 0 1 6 4]\n[6, 0, 2, 0, 6, 3, 3, 7, 2, 0, 5, 4]\n```\n\nそこそこ? [Tensorflowでやってみる](https://gist.github.com/fumiakiy/c1f8fe23b36b0a8984a12cd2bb54cd0e)とどうだろう。\n\n```\n$ python tf2.py\n```\n\n```\nTest set accuracy: 0.195\n```\n\n```\nPrediction is “4” (15.8%), expected “2”\n```\n\n```\nPrediction is “4” (15.8%), expected “0”\n```\n\n```\nPrediction is “4” (15.8%), expected “1”\n```\n\nガーン。ものの見事に全然区別できてない。ニューラルネットワーク様にはもっとたくさんデータを食わせないとダメなのかあとか思いながら、アルゴリズムを変えてみたりあーだこーだしていてふと気づいた。DNNClassifierに渡している「hidden_units」ってなんだ。\n\nニューラルネットワークでディープラーニングってのは、[それっぽい絵](https://www.mapleprimes.com/maplesoftblog/209354-A-Beginners-Guide-To-Using-The-DNN)を見てみると、入力から出力の間に通る場所をいくつも作っていくものらしい。どこかのサンプルから写経した[10, 10]を渡しているけど、これはニューラルネットワークのinputとoutputの間にあるよくわからん神経ノードの数と層を表しているのだから、ここを増やせば精度が上がるんじゃないか? データも少ないし、適当に[20, 40, 20]などと渡してみた（前掲リンク先のを真似した）。\n\n```\n$ python tf2.py\nTest set accuracy: 0.929\n```\n\n```\nPrediction is “2” (100.0%), expected “2”\n```\n\n```\nPrediction is “0” (100.0%), expected “0”\n```\n\n```\nPrediction is “1” (48.4%), expected “1”\n```\n\n…精度が急上昇しました。\n\nちょっと本当かなと思って、[20, 40, 80, 40, 20]とかも渡してみたら精度が1.000のオール100%なんてことになったこともあったんだけど、こんな程度のデータ量だと(?)試行するたびに全然違う数値が出てくるので、一喜一憂しても仕方ない。このままデータを増やしていっても、aとdをより精度高く判別できるようになるとは正直思えないし。\n\nだが、まあとりあえず小文字のアルファベットのデータを全部作って、できたモデルをTensorflow Liteに乗せてAndroidで実行してみるモチベーションが湧くくらいの精度ではあるので、次に進もうと思う。\n\n[Levi’s Commuter Trucker Jacket with Jacquard by Googleの袖から来たデータを機械学習してAndroidアプリで利用できるモデルを作る](/blog/2019-07-04_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google----------------Android----------------a4747b4edca5)へ続く。\n\n","navs":{"nextPage":{"epoch":"1562273126","title":"Levi’s Commuter Trucker Jacket with Jacquard by Googleの袖から来たデータを機械学習してAndroidアプリで利用できるモデルを作る","slug":"/blog/2019-07-04_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google----------------Android----------------a4747b4edca5"},"prevPage":{"epoch":"1560613461","title":"Levi’s Commuter Trucker Jacket with Jacquard by Googleの袖を手書き認識デバイスにする","slug":"/blog/2019-06-15_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google----------------1ae6347c67fc"}}},"__N_SSG":true}