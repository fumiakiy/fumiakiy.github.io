<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AndroidアプリとデバイスとのBluetoothでの通信内容を解析する</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fumiakiy"/><meta name="og:title" content="AndroidアプリとデバイスとのBluetoothでの通信内容を解析する"/><meta name="twitter:title" content="AndroidアプリとデバイスとのBluetoothでの通信内容を解析する"/><meta name="description" content="Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れたの続き。"/><meta name="og:description" content="Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れたの続き。"/><meta name="twitter:description" content="Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れたの続き。"/><link rel="prev" href="https://luckypines.com/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5"/><link rel="next" href="https://luckypines.com/blog/2019-06-01_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google------------8b56fb4732d7"/><meta name="next-head-count" content="12"/><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-50700-3"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag("js", new Date());
  gtag("config", "UA-50700-3");

  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);
  
    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };
  
    return t;
  }(document, "script", "twitter-wjs"));
  </script><link rel="alternate" type="application/atom+xml" title="Atom feed for blog by Fumiaki Yoshimatsu" href="https://luckypines.com/feed.atom"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/a233f8e7bb0aab01.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a233f8e7bb0aab01.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a85ef328f9b29345.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a85ef328f9b29345.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-f635b472c367d1c7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3c378216e12a202e.js" defer=""></script><script src="/_next/static/chunks/929-7a82b6373bf08faf.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bpostname%5D-5b6da21245e44f1e.js" defer=""></script><script src="/_next/static/g20-O6QVgSaqC3roOtI35/_buildManifest.js" defer=""></script><script src="/_next/static/g20-O6QVgSaqC3roOtI35/_ssgManifest.js" defer=""></script><script src="/_next/static/g20-O6QVgSaqC3roOtI35/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap">@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vqPQA.woff) format('woff')}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_7PqPQA.woff) format('woff')}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_Of2PQA.woff) format('woff')}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSV0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSx0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSt0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSd0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSZ0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSh0me8iUI0.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSV0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSx0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSt0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSd0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSZ0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSh0me8iUI0.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSV0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSx0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSt0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSd0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSZ0me8iUI0lkQ.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/robotomono/v13/L0xTDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vrtSM1J-gEPT5Ese6hmHSh0me8iUI0.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next" data-reactroot=""><div class="blog"><article class="BlogPost_article__wA_OL"><h1>AndroidアプリとデバイスとのBluetoothでの通信内容を解析する</h1><div>5/12/2019, 11:43:30 AM</div><div class="BlogPost_body__N7rlb"><h3>AndroidアプリとデバイスとのBluetoothでの通信内容を解析する</h3>
<div><a href="/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5">Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れた</a>の続き。</div>
<div>Jacquardのジャケットとsnap tagの機能を利用するAndroidアプリを作るために、まずは公式アプリでは何をどうやっているのかを調べてみた。前回の記事で触れたとおり、JacquardのサービスのUUIDといくつかのcharacteristicのUUIDはわかったので、それらに向けていつどんなデータが飛んでいるのか、特にLEDを光らせるコマンドはどうやって送られているのかを調べる。</div>
<h3>AndroidでBluetoothログを取る</h3>
<div>まずは、公式アプリで3つのうちのどれかのアクションにLightを割り当てておく。</div>
<div>また、Androidの設定で<a href="https://developer.android.com/studio/debug/dev-options">Developer Optionsの中にある「Enable Bluetooth Host Controller Interface (HCI</a> snoop log」をオンにして)、Bluetoothを切って再度オンにしてやる。これでBluetoothでの通信内容がログに保存される。</div>
<div>そうしてから、Jacquardの3種類のLEDモード（白く光らせるFlash Light、赤く点滅させるSignal、7色?に回転するParty?）を順番に割り当てて、実際に動作させてみる。するとそれぞれの動作は、どれも起動してから30秒で自動終了すること、また実行中にもう一度同じことをする（Brush Inするとか）と停止できることがわかった。</div>
<div>それぞれの動作を行った時間をなんとなく記録して、adbでデバイスからBluetoothログを取得する。<a href="https://developer.android.com/studio/debug/dev-options">ドキュメント</a>には「Captures all Bluetooth HCI packets in a file stored at “/sdcard/btsnoop_hci.log”」って書いてあるんだけども、最近のAndroidではこのファイルが作られるわけではなく、ログを見るにはbugreportするのが正解らしい。</div>
<div><code>adb bugreport hoge</code>とやると、hoge.zipが落ちてくるので、<code>unzip hoge.zip FS/data/misc/bluetooth/logs/btsnoop_hci.log</code>してログを手に入れた。</div>
<h3>WiresharkでBluetoothログ解析</h3>
<div><code>btsnoop_hci.log</code>はそのまま人間が読むためのテキストログではないのだけど、幸いなことに<a href="https://www.wireshark.org/">Wireshark</a>がいい感じにやってくれるので、Wiresharkでファイルを開く。だいたいこんな時間帯にこれをやったよな、ってあたりのログを見て、それらしき通信を探す…</div>
<div>探す…んだけど、<a href="/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5">前回あたりをつけた</a>サービスやcharacteristicのUUIDが全然見つからなかった。あたりはハズレでした。</div>
<div>しかたないので、それらしき時間帯で共通に発生しているらしくて、他の時間帯には発生していないと思われる、ような気がするかもしれない感じのログエントリーを探してみる。すると、snap tag上のサービス「d2f2bf0d-d165–445c-b0e1–2d6b642ec57b」、characteristic「d2f2eabb-d165–445c-b0e1–2d6b642ec57b」に対して謎の値をwriteしていることがわかった。</div>
<div>さらに、その謎の値をwriteした後すぐに、同じサービスの同じcharacteristicから別の値をreadしていること、その30秒後にまた同じサービスの同じcharacteristicから別の値をreadしていることが判明する。しかも3種類のLEDの光らせ方それぞれを行った時間帯にそれぞれ、writeとreadの値だけが異なる通信をしている。これは怪しい。</div>
<div>何度かLEDを光らせてはログを取ってみると、これらの値は毎回若干異なるもののある種のパターンがあり、全然変わらない部分、毎回変わる部分、光らせ方によって変わる部分があることがわかった。例えば赤点滅モードの場合の値は「c0110800100818<strong>06</strong>da060808<strong>20</strong>107830013801」だったり「c0110800100818<strong>1a</strong>da060808<strong>20</strong>107830013801」だったりするが、Partyモードの値は「c0110800100818<strong>05</strong>da060808<strong>10</strong>107830013801」だったり「c0110800100818<strong>1b</strong>da060808<strong>10</strong>107830013801」だったりする。</div>
<div>そこで、とりあえず自作Androidアプリから同じUUIDsに対してログと同じような値を送りつけてみたらどうなるか、やってみることにした。</div>
<h3>Bluetooth Low Energyのperipheralにコマンドを送る</h3>
<div>こんな感じのコードを書いて、BLEデバイスを見つけて、接続して、characteristicを取得して、それに値を書きこんでみる。これが動けば、<code>startScan</code>してすぐにsnap tagが光るはず…。</div>
<pre><code>private val blinkInRed: ByteArray get() { ... }
</code></pre>
<pre><code>private val bluetoothAdapter: BluetoothAdapter? by lazy(LazyThreadSafetyMode.NONE) {
  val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
  bluetoothManager.adapter
}
</code></pre>
<pre><code>private var scanner: BluetoothLeScanner? = null
private var gatt: BluetoothGatt? = null
</code></pre>
<pre><code>fun startScan() {
  scanner = bluetoothAdapter?.bluetoothLeScanner
</code></pre>
<pre><code>  val filter = ScanFilter.Builder()
    .setServiceUuid(ParcelUuid(SERVICE_UUID))
    .build()
  val option = ScanSettings.Builder()
    .setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)
    .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)
    .build()
</code></pre>
<pre><code>  // Start searching the service advertised from a device
  // Get the result in `scanCallback` below
  scanner?.startScan(listOf(filter), option, scanCallback)
}
</code></pre>
<pre><code>private val scanCallback = object: ScanCallback() {
  override fun onScanResult(
    callbackType: Int,
    result: ScanResult?)
  {
    result?.let {
      // Found the service. Connect to the device
      // Get the connection result in `gattCallback` below
      gatt = it.device.connectGatt(context, false, gattCallback)
    }
  }
}
</code></pre>
<pre><code>private val gattCallback = object: BluetoothGattCallback() {
  override fun onConnectionStateChange(
    gatt: BluetoothGatt?,
    status: Int,
    newState: Int)
  {
    if (status == BluetoothGatt.GATT_SUCCESS) {
      when (newState) {
        BluetoothProfile.STATE_CONNECTED -&amp;gt; {
          gatt?.let {
           // Connected to the device. Lookup the service
           // Results come in to `onServicesDiscovered` below
           it.discoverServices()
          }
        }
      }
    }
  }
</code></pre>
<pre><code>  override fun onServicesDiscovered(
    gatt: BluetoothGatt,
    status: Int)
  {
    when (status) {
      BluetoothGatt.GATT_SUCCESS -&amp;gt; {
        gatt.getService(SERVICE_UUID)?.let { s -&amp;gt;
          // Found the service. Lookup the characteristic
          s.getCharacteristic(CHARACTERISTIC_UUID)?.let { c -&amp;gt;
          // Set the binary value to the characteristic
            c.setValue(blinkInRed)
            // Write the value to the characteristic
            // This should light up the LED on the snap tag
            gatt?.writeCharacteristic(c)
          }
        }
      }
    }
  }
}
</code></pre>
<div>まあ光りませんよね。</div>
<div>そもそもscanに成功しなくなった。それもそのはずで、公式アプリとsnap tagを接続してしまっていたので、snap tagはadvertisementをやめているぽかった。なので、いったん公式アプリでsnap tagをforgetし、Androidの設定からBluetoothデバイス「Jacquard」もforgetする。すると、scanに成功して、connectからcharacteristicを見つけるところまで進むようになった。</div>
<div>が、やはり光らない。<code>writeCharacteristic</code>はtrueを返してきたりするんだけど、光らない。このアプリの通信をBluetoothのログをWiresharkで見てみたけど、送っている値や何かが間違っている気配はない。</div>
<div>ここで気になったのは2点。まず、Androidが執拗に「Jacquardからparing requestが来てるけどpairする?」というポップアップが出続けること。まあこれは無視していたんだけど、もう1点、もしこのコードが動作するようなら、そこいら辺にある他人のsnap tagを光らせ放題じゃないか?</div>
<h3>Bluetooth Low Energyにおけるconnectとpairとbond</h3>
<div>当然なんだけど、BLEにはちゃんとセキュリティ、特に飛び交うデータの暗号化に関する仕様があって、それを理解しておけって話なんだけども、簡単にいうとググってこの<a href="https://devzone.nordicsemi.com/f/nordic-q-a/11939/connecting-bonding-pairing-and-whitelists/45217#45217">connecting, pairing and bondingに関する説明</a>を発見して納得した。connectしただけで見られる情報だけでは（おそらく多くの場合で）デバイスの機能を利用することはできず、それをするには鍵交換を行った上でデータを暗号化してやりとりしなければならないと。</div>
<div>となると、Wiresharkで見た情報は鍵が変われば変わってしまうのでは? 鍵はperipheralとclientが同じでも毎回変わるのか?</div>
<div>どうやってそれを調べられるのかわからないので、とりあえず公式アプリを一度アンインストールして、再度インストールして、接続してログを見てみた。値は変わっていなかった。これは多分違うAndroidデバイスだと違う値になるんだろうなあ、当然snap tagが変わればまた違う値になるんだろうなあ、となると、Wiresharkで見た値そのものを公開したところで、他の人はその値を使えないだろうなあ。でも「俺専用の俺アプリ」を作る分にはまあ動くのかも。</div>
<h3>Let there be light</h3>
<div>というところまで考えたところで、Androidのドキュメントに戻って、<a href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#setPin%28byte%5B%5D%29">BluetoothDevice#setPin(byte[] pin</a>)と<a href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#createBond%28%29">BluetoothDevice#createBond(</a>)を見つけた。pinの値は、ジャケットを持っていれば知っているはずのアレで、ジャケットにくっついている。公式アプリはこれを入力しなくても値を表示してくれるので、snap tagはこの値もadvertiseしているはずなんだけど、それを探すのは後回し。</div>
<div>そういうわけで、<code>discoverServices()</code>を呼び出す前に<code>setPin</code>と<code>createBond</code>を呼び出してしまう。</div>
<pre><code>gatt?.let {
  // Connected to the device. Pair, bond
  it.device.setPin(myJacketPin)
  it.device.createBond()
  // And then lookup the service
  // Results come in to `onServicesDiscovered` below
  it.discoverServices()
}
</code></pre>
<div>光った！光ったよ！Wiresharkで見た値をそのまま送りつけただけですが、無事光りました。</div>
<div>本当は<code>createBond</code>の成否をBroadcastReceiverで受け取ってから操作しないといけないのだが、いったんbondしてしまえば次からはまあ速いので、こんなコードでもちゃんと動いた。</div>
<div><a href="/blog/2019-06-01_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google------------8b56fb4732d7">Levi’s Commuter Trucker Jacket with Jacquard by Googleを操る自作アプリを作る</a>へ続く。</div></div></article></div><footer class="BlogPost_footer__4tSVP"><a class="BlogPost_prev__r_UG_" href="/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5/">« <!-- -->Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れた</a><a href="/blog/">Blog</a><a class="BlogPost_next__kILUp" href="/blog/2019-06-01_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google------------8b56fb4732d7/">Levi’s Commuter Trucker Jacket with Jacquard by Googleを操る自作アプリを作る<!-- --> » </a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"slug":"/blog/2019-05-12_Android----------Bluetooth------------5844e20b5b98","date":"Sun, 12 May 2019 15:43:30 GMT","title":"AndroidアプリとデバイスとのBluetoothでの通信内容を解析する","epoch":"1557675810","excerpt":"Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れたの続き。"},"markdownBody":"\n### AndroidアプリとデバイスとのBluetoothでの通信内容を解析する\n\n[Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れた](/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5)の続き。\n\nJacquardのジャケットとsnap tagの機能を利用するAndroidアプリを作るために、まずは公式アプリでは何をどうやっているのかを調べてみた。前回の記事で触れたとおり、JacquardのサービスのUUIDといくつかのcharacteristicのUUIDはわかったので、それらに向けていつどんなデータが飛んでいるのか、特にLEDを光らせるコマンドはどうやって送られているのかを調べる。\n\n### AndroidでBluetoothログを取る\n\nまずは、公式アプリで3つのうちのどれかのアクションにLightを割り当てておく。\n\nまた、Androidの設定で[Developer Optionsの中にある「Enable Bluetooth Host Controller Interface (HCI](https://developer.android.com/studio/debug/dev-options) snoop log」をオンにして)、Bluetoothを切って再度オンにしてやる。これでBluetoothでの通信内容がログに保存される。\n\nそうしてから、Jacquardの3種類のLEDモード（白く光らせるFlash Light、赤く点滅させるSignal、7色?に回転するParty?）を順番に割り当てて、実際に動作させてみる。するとそれぞれの動作は、どれも起動してから30秒で自動終了すること、また実行中にもう一度同じことをする（Brush Inするとか）と停止できることがわかった。\n\nそれぞれの動作を行った時間をなんとなく記録して、adbでデバイスからBluetoothログを取得する。[ドキュメント](https://developer.android.com/studio/debug/dev-options)には「Captures all Bluetooth HCI packets in a file stored at “/sdcard/btsnoop_hci.log”」って書いてあるんだけども、最近のAndroidではこのファイルが作られるわけではなく、ログを見るにはbugreportするのが正解らしい。\n\n`adb bugreport hoge`とやると、hoge.zipが落ちてくるので、`unzip hoge.zip FS/data/misc/bluetooth/logs/btsnoop_hci.log`してログを手に入れた。\n\n### WiresharkでBluetoothログ解析\n\n`btsnoop_hci.log`はそのまま人間が読むためのテキストログではないのだけど、幸いなことに[Wireshark](https://www.wireshark.org/)がいい感じにやってくれるので、Wiresharkでファイルを開く。だいたいこんな時間帯にこれをやったよな、ってあたりのログを見て、それらしき通信を探す…\n\n探す…んだけど、[前回あたりをつけた](/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5)サービスやcharacteristicのUUIDが全然見つからなかった。あたりはハズレでした。\n\nしかたないので、それらしき時間帯で共通に発生しているらしくて、他の時間帯には発生していないと思われる、ような気がするかもしれない感じのログエントリーを探してみる。すると、snap tag上のサービス「d2f2bf0d-d165–445c-b0e1–2d6b642ec57b」、characteristic「d2f2eabb-d165–445c-b0e1–2d6b642ec57b」に対して謎の値をwriteしていることがわかった。\n\nさらに、その謎の値をwriteした後すぐに、同じサービスの同じcharacteristicから別の値をreadしていること、その30秒後にまた同じサービスの同じcharacteristicから別の値をreadしていることが判明する。しかも3種類のLEDの光らせ方それぞれを行った時間帯にそれぞれ、writeとreadの値だけが異なる通信をしている。これは怪しい。\n\n何度かLEDを光らせてはログを取ってみると、これらの値は毎回若干異なるもののある種のパターンがあり、全然変わらない部分、毎回変わる部分、光らせ方によって変わる部分があることがわかった。例えば赤点滅モードの場合の値は「c0110800100818**06**da060808**20**107830013801」だったり「c0110800100818**1a**da060808**20**107830013801」だったりするが、Partyモードの値は「c0110800100818**05**da060808**10**107830013801」だったり「c0110800100818**1b**da060808**10**107830013801」だったりする。\n\nそこで、とりあえず自作Androidアプリから同じUUIDsに対してログと同じような値を送りつけてみたらどうなるか、やってみることにした。\n\n### Bluetooth Low Energyのperipheralにコマンドを送る\n\nこんな感じのコードを書いて、BLEデバイスを見つけて、接続して、characteristicを取得して、それに値を書きこんでみる。これが動けば、`startScan`してすぐにsnap tagが光るはず…。\n\n```\nprivate val blinkInRed: ByteArray get() { ... }\n```\n\n```\nprivate val bluetoothAdapter: BluetoothAdapter? by lazy(LazyThreadSafetyMode.NONE) {\n  val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\n  bluetoothManager.adapter\n}\n```\n\n```\nprivate var scanner: BluetoothLeScanner? = null\nprivate var gatt: BluetoothGatt? = null\n```\n\n```\nfun startScan() {\n  scanner = bluetoothAdapter?.bluetoothLeScanner\n```\n\n```\n  val filter = ScanFilter.Builder()\n    .setServiceUuid(ParcelUuid(SERVICE_UUID))\n    .build()\n  val option = ScanSettings.Builder()\n    .setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)\n    .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)\n    .build()\n```\n\n```\n  // Start searching the service advertised from a device\n  // Get the result in `scanCallback` below\n  scanner?.startScan(listOf(filter), option, scanCallback)\n}\n```\n\n```\nprivate val scanCallback = object: ScanCallback() {\n  override fun onScanResult(\n    callbackType: Int,\n    result: ScanResult?)\n  {\n    result?.let {\n      // Found the service. Connect to the device\n      // Get the connection result in `gattCallback` below\n      gatt = it.device.connectGatt(context, false, gattCallback)\n    }\n  }\n}\n```\n\n```\nprivate val gattCallback = object: BluetoothGattCallback() {\n  override fun onConnectionStateChange(\n    gatt: BluetoothGatt?,\n    status: Int,\n    newState: Int)\n  {\n    if (status == BluetoothGatt.GATT_SUCCESS) {\n      when (newState) {\n        BluetoothProfile.STATE_CONNECTED -\u0026gt; {\n          gatt?.let {\n           // Connected to the device. Lookup the service\n           // Results come in to `onServicesDiscovered` below\n           it.discoverServices()\n          }\n        }\n      }\n    }\n  }\n```\n\n```\n  override fun onServicesDiscovered(\n    gatt: BluetoothGatt,\n    status: Int)\n  {\n    when (status) {\n      BluetoothGatt.GATT_SUCCESS -\u0026gt; {\n        gatt.getService(SERVICE_UUID)?.let { s -\u0026gt;\n          // Found the service. Lookup the characteristic\n          s.getCharacteristic(CHARACTERISTIC_UUID)?.let { c -\u0026gt;\n          // Set the binary value to the characteristic\n            c.setValue(blinkInRed)\n            // Write the value to the characteristic\n            // This should light up the LED on the snap tag\n            gatt?.writeCharacteristic(c)\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nまあ光りませんよね。\n\nそもそもscanに成功しなくなった。それもそのはずで、公式アプリとsnap tagを接続してしまっていたので、snap tagはadvertisementをやめているぽかった。なので、いったん公式アプリでsnap tagをforgetし、Androidの設定からBluetoothデバイス「Jacquard」もforgetする。すると、scanに成功して、connectからcharacteristicを見つけるところまで進むようになった。\n\nが、やはり光らない。`writeCharacteristic`はtrueを返してきたりするんだけど、光らない。このアプリの通信をBluetoothのログをWiresharkで見てみたけど、送っている値や何かが間違っている気配はない。\n\nここで気になったのは2点。まず、Androidが執拗に「Jacquardからparing requestが来てるけどpairする?」というポップアップが出続けること。まあこれは無視していたんだけど、もう1点、もしこのコードが動作するようなら、そこいら辺にある他人のsnap tagを光らせ放題じゃないか?\n\n### Bluetooth Low Energyにおけるconnectとpairとbond\n\n当然なんだけど、BLEにはちゃんとセキュリティ、特に飛び交うデータの暗号化に関する仕様があって、それを理解しておけって話なんだけども、簡単にいうとググってこの[connecting, pairing and bondingに関する説明](https://devzone.nordicsemi.com/f/nordic-q-a/11939/connecting-bonding-pairing-and-whitelists/45217#45217)を発見して納得した。connectしただけで見られる情報だけでは（おそらく多くの場合で）デバイスの機能を利用することはできず、それをするには鍵交換を行った上でデータを暗号化してやりとりしなければならないと。\n\nとなると、Wiresharkで見た情報は鍵が変われば変わってしまうのでは? 鍵はperipheralとclientが同じでも毎回変わるのか?\n\nどうやってそれを調べられるのかわからないので、とりあえず公式アプリを一度アンインストールして、再度インストールして、接続してログを見てみた。値は変わっていなかった。これは多分違うAndroidデバイスだと違う値になるんだろうなあ、当然snap tagが変わればまた違う値になるんだろうなあ、となると、Wiresharkで見た値そのものを公開したところで、他の人はその値を使えないだろうなあ。でも「俺専用の俺アプリ」を作る分にはまあ動くのかも。\n\n### Let there be light\n\nというところまで考えたところで、Androidのドキュメントに戻って、[BluetoothDevice#setPin(byte[] pin](https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#setPin%28byte%5B%5D%29))と[BluetoothDevice#createBond(](https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#createBond%28%29))を見つけた。pinの値は、ジャケットを持っていれば知っているはずのアレで、ジャケットにくっついている。公式アプリはこれを入力しなくても値を表示してくれるので、snap tagはこの値もadvertiseしているはずなんだけど、それを探すのは後回し。\n\nそういうわけで、`discoverServices()`を呼び出す前に`setPin`と`createBond`を呼び出してしまう。\n\n```\ngatt?.let {\n  // Connected to the device. Pair, bond\n  it.device.setPin(myJacketPin)\n  it.device.createBond()\n  // And then lookup the service\n  // Results come in to `onServicesDiscovered` below\n  it.discoverServices()\n}\n```\n\n光った！光ったよ！Wiresharkで見た値をそのまま送りつけただけですが、無事光りました。\n\n本当は`createBond`の成否をBroadcastReceiverで受け取ってから操作しないといけないのだが、いったんbondしてしまえば次からはまあ速いので、こんなコードでもちゃんと動いた。\n\n[Levi’s Commuter Trucker Jacket with Jacquard by Googleを操る自作アプリを作る](/blog/2019-06-01_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google------------8b56fb4732d7)へ続く。\n\n","navs":{"nextPage":{"epoch":"1559401781","title":"Levi’s Commuter Trucker Jacket with Jacquard by Googleを操る自作アプリを作る","slug":"/blog/2019-06-01_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google------------8b56fb4732d7"},"prevPage":{"epoch":"1557097032","title":"Levi’s Commuter Trucker Jacket with Jacquard by Google を手に入れた","slug":"/blog/2019-05-05_Levi-s-Commuter-Trucker-Jacket-with-Jacquard-by-Google--------f37ae5a4cde5"}}},"__N_SSG":true},"page":"/blog/[postname]","query":{"postname":"2019-05-12_Android----------Bluetooth------------5844e20b5b98"},"buildId":"g20-O6QVgSaqC3roOtI35","runtimeConfig":{},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>